**合成事件的实现机制**

在`React`底层,主要对合成事件做了两件事: 时间为拍和自动绑定

**事件委派**



​	它不会吧事件处理函数直接绑定到真实的节点上,而是把所有事件绑定到结构的最外层,使用一个统一的事件监听器,这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数

​	当组件挂在或卸载时,只是在这个统一的事件监听器上插入或删除一些对象,当事件发生时,首先被这个统一的事件监听器处理,然后在映射里找到真正的事件处理函数并调用

​	这样简化了事件处理和回收机制,效率也有很大提升

**自动绑定**

​	在`React`组件中,每个方法的上下文都会执行该组件的实例,即自动绑定`this`

```js
render(){
	<button onclick={this.handleClick.bind(this,'text')}></button>
}
```

**React使用原生事件**

​	使用`DOM`原生事件时,一定要在组件卸载时手动移除,否则很可能出现内存泄漏的问题

​	`dialog`点击空白处,需要使用原生事件,我们无法在组件中将事件绑定到`body`上,因为`body`在组件范围之外,只能使用原生绑定事件来实现



​	尽量米面在`React`中混用合成事件和原生`DOM`事件,阻止`React`事件冒泡的行为只能用于`React`合成事件系统中,且没有办法阻止原生事件的冒泡.反之,在原生事件中的阻止冒泡行为,却可以阻止`React`合成事件的传播

## 问题

事件代理?

合成事件和原生事件混用问题