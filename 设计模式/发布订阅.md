# 发布-订阅

**发布-订阅&观察者模式**	

​	发布-订阅又叫观察者模式,有些地方将两者又进行了细分发布订阅实现了解耦

​	发布-订阅是两个人之间独立的,没有关联,自己订阅,自己发布

​	观察者模式两个人之间有关联被观察者收集了所有需要观察的人,状态改变,自己通知所有人

区别:

1. 观察者模式,观察者是知道Subject的,Subject一直保持对观察者进行记录.然而,在发布订阅模式中,发布者和订阅者不知道对方的存在,他们只有通过消息代理进行通信
2. 观察者模式大多数是同步的,而发布订阅模式大多数时候是异步的(使用消息队列)
3. 

```js
#观察者
╭─────────────╮  Fire Event  ╭──────────────╮
 │             │─────────────>│                │
 │   Subject   │              │   Observer     │
 │             │<─────────────│                │
 ╰─────────────╯  Subscribe   ╰──────────────╯
 #发布-订阅
 ╭─────────────╮                 ╭───────────────╮   Fire Event   ╭──────────────╮
 │              │  Publish Event  │                  │───────────────>│              │
 │  Publisher   │────────────────>│ Event Channel    │                │  Subscriber  │
 │              │                 │                  │<───────────────│              │
 ╰─────────────╯                 ╰───────────────╯    Subscribe   ╰──────────────╯
 
```



**定义**

​	发布-订阅定义对象间一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖与它的对象都将得到通知,在JS中,我们一般用事件模型来代替传统的发布-订阅(DOM节点挂载多个事件)

**优点**	

1. **时间上的解耦,**使用发布-订阅我们就无需关注异步运行期间的内部状态,只需要订阅感兴趣的事件
2. **对象间的解耦**,对象间不关注彼此的细节,当有新的订阅者出现时,发布者的代码不需要任何修改,同样发布者需要改变时,也不会影响到之前的订阅者,只要约定的事件名没有变化,就可以自由的改变他们

**缺点**

1. 创建订阅者本身要消耗一定的时间和内存
2. 订阅消息可能最后都没有发生,但这个订阅者会始终存在于内存中
3. 发布-订阅会弱化对象之间的联系,过度使用对象和对象之间的联系会被深埋在背后,会导致程序难以跟踪维护和理解,特别是多个发布者和订阅者嵌套在一起的时候

**推拉模型**

- 推模型

  事件发生时,发布者一次把所有更改的状态和数据都推送给订阅者

- 拉模型

  发布者仅仅通知订阅者事件已经发生了,此外发布者要提供一些公开的接口供订阅者来主动拉取数据,拉模型的好处是可以让订阅者**按需获取**

​	

**发布/订阅 解决高并发问题**

​	当已经去查询数据库`ready`时,再次发来请求查询,会都订阅到`selected`中,避免多次请求数据库,数据回来后使用`emit`进行分发

```js
var event= new events;
var status = "ready";  //状态锁  ready为准备中  pending为执行中
var select = function (callback) {
    event.once("selected", callback);
    if (status === "ready") {
         status = "pending";
         db.select("SQL", function (results) {
            event.emit("selected", results);
            status = "ready";
         });
     }
};
```

