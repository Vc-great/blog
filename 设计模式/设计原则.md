#  设计原则

​	设计模式的主题总是把不变的和变化的事物分离开来

## SOLID

### SRP 单一职责原则

​	一个程序只做好一件事,如果功能过于复杂就拆分开,每个部分保持独立

​	**何时应该分离职责**

1. 如果随着需求的变化,有两个职责总是同时变化,那就不必分离
2. 职责的变化轴线仅当他们确定会发生变化时才具有意义,即使两个职责已经被耦合在一起,单他们还没有发生改变的征兆,那么也许没有必要主动分离它们,在代码需要重构的时候再进行分离

**违反SRP原则**

​	在方便性与稳定性之间要有一些取舍,看业务场景

**优点**

​	降低了单个类或者对象的复杂度,按照职责把对象分解成更小的粒度,有助于代码的复用,当一个职责改变的时候不会影响到其他的职责

**缺点**

​	增加代码的复杂度

### O-开放封闭原则

对扩展开放,对修改封闭

增加需求时,扩展信贷吗,而非修改已有代码

### L-李氏转换原则

子类能覆盖父类,子类能覆盖父类的功能

所有父类能出现的地方,子类都能出现

### I-接口独立原则

​	保持接口的单一独立

​	我们应该将那些非常大的接口（**大而全**）拆分成一些小的更具体的接口，这样客户端就秩序关心他们需要用到的接口

### D-依赖导致原则

面向接口编程,依赖于抽象而不依赖于具体

使用方只关注接口而不关注具体类的实现

## 最少知识原则LKP(迪米特法则)

​	一个软件实体应当尽可能少地与其他实体发生相互作用

**解释:**

​	将军通知上校,上校通知上尉,上尉通知军士,军士通知士兵挖坑

**减少对象之间的联系**

​	多对象之间可能会产生负责的联系,修改其中一个很可能会影响到跟它相互引用的其他对象,对象的'朋友'太多不是好事

​	最少知识原则就是要求尽量减少对象之间的交互,如果两个对象之间不必彼此直接通信,这两个对象就不要发生直接的相互联系

​	常见的做法是引入一个第三者,来承担这些对象之间的通信作用

**相关设计模式**

1. 中介者模式

   通过增加一个中介者,让所有相关对象都通过中介者对象来通信,而不是相互引用

## 开发-封闭原则OCP

​	当需要改变一个程序的功能或者给这个程序增加新功能的时候,可以使用增加代码的方式,但是不允许改动程序的源代码

**找出变化的地方**	

​	把系统中稳定不变的部分和容易变化的部分隔离开来,代码演变的过程中我们只需要替换哪些容易变化的部分

1. 对象的多态

   同一操作作用于不同的对象,可以有不同的解释,产生不同的执行结果

   ```js
   1.可以有多种动物其中叫是不变的
   2.动物和叫声分开
   var makeSound = function(animal){
   	animal.sound()
   }
   #Dog
   let Dog = function(){}
   Dog.prototype.sound = function(){}
   
   #Duck
   let Duck = function(){}
   Duck.prototype.sound = function(){}
   ```

2. 放置倒勾(hook)

   在有可能变化的地方放置一个挂钩,挂钩的返回结果决定了程序的的下一步走向,程序未来的执行方向就被埋下了多种可能性

3. 回调函数

   函数作为参数,通常把这个函数称为回调函数,回调函数是一种特殊的挂钩,把易于变化的逻辑封装在回调函数里,根据回调函数的内部逻辑不同,而产生不同的结果

   - 发布-订阅模式

     用来降低多个对象之间的依赖关系,他可以取代对象之间硬编码的通知机制,一个对象不用载显示地调用另外一个对象的某个接口,当有新的订阅者出现时,发布者的代码不需要进行任何修改;同样当发布者需要改变时,也不会影响到之前的订阅者

   - 模版方法模式

     

   - 策略模式

   - 代理模式
   - 职责链模式

   **开放-封闭原则的相对性**

1. 挑选出最容易发生变化的地方,然后构造抽象来封闭这些变化
2. 在不可避免发生修改的时候,尽量修改哪些相对容易修改的地方,**比如:**修改它提供的配置文件,总比修改它的源代码来的简单