# 设计模式

## 创建型

1. 工厂模式

2. 抽象工厂

3. 单例模式

   单一职责,只实例化唯一的对象

4. 原型模式

   new开销大

   clone自己,生成一个新对象

   Object.create

5. 建造者

## 结构型

1. 适配器模式

   旧的和使用者分离,增加适配器

2. 装饰器模式

   为对象添加新功能

   不改变其原有的结构和功能

   ```
   ES7 
   babel-plugin-transform-decorator-legacy
   
   库
   core-decorators
   ```

   

3. 代理模式

   使用者无权访问目标对象

   代理类和目标类分离,隔离开目标类和使用者

   中间加代理,通过代理做授权和控制

4. 外观模式

   为子系统中的一组接口提供了一个高层接口

   使用者使用这个高层接口

5. 桥接模式

6. 组合模式

7. 享元模式

## 行为型

1. 策略模式

2. 模版方法模式

3. 观察者模式  **重点**

   主题和观察者分离,不是主动触发而是被动监听,两者解耦

   主题: 保存状态,装填变化之后触发所有观察者对象

   每个data属性都是一个主题,当data改变后会触发所有观察者

4. 迭代器模式 **重点**

   顺序访问一个集合

   使用者无需知道集合的内部结构

   迭代器对象和目标对象分离

   迭代器将使用者与目标对象隔离开

5. 职责连模式

6. 命令模式

7. 备忘录模式

8. 状态模式 **重点**

   状态对象和主体对象分离

   状态的变化逻辑单独处理

   ```
   灯的状态是单独的 红黄绿
   
   //主体   
   ```

   

9. 访问者模式

10. 中介者模式

11. 解释器模式

    

## 代理模式&适配器模式

适配器模式:提供一个不同的接口

代理模式: 提供一模一样的接口



装饰器模式: 扩展功能,原有功能不变且可直接使用

代理模式: 显示原有功能,但是经过限制或者阉割之后的

