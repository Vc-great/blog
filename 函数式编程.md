# 函数式编程

## 声明式与命令式

**声明式**

​	将程序的的描述与求值分离开来,它关注如何用各种表达式来描述程序逻辑,而不一定要指明其控制流或状态的变化

```js
蔬菜(类) => 做成菜(方法), 接受入参(各种菜)

蔬菜.做成菜(牛油果，各种蔬菜)； // 沙拉
蔬菜.做成菜(胡萝卜，青菜，油)； // 炒蔬菜
```



**命令式**

​	命令式关注点在于**我们如何去做**,更加在乎计算机执行的步骤,一步一步先做什么,再做什么,把细节按照人类的思想以代码的形式表现出来

```js
洗干净(蔬菜)
混合(蔬菜,沙拉)
放入盘中(混合物)
```

**函数式**

​	函数式编程是声明式编程的一部分,是指为创建不可变的程序,通过消除外部可见的副作用,来对纯函数声明式的求值过程

​	函数式编程是一种强调以函数使用为主的软件开发风格,函数式编程的目标是使用函数来抽象作用在数据之上的控制流与操作,从而在系统中消除副作用并减少对状态的改变

​	函数式编程旨在尽可能地提高代码的无状态性和不变性,无状态的代码不会改变或破坏全局的状态,要学会使用没有副作用和状态变化的函数--**纯函数**

**函数式优点**

1. 促使将任务分解成简单的函数
2. 使用流式的调用链来处理数据
3. 通过响应式范式降低事件驱动代码的复杂性
4. 声明式的编程，易于推理，提高了程序的可读性，使用组合和lambda使代码更加精简

## 闭包

   闭包就是能够读取其他函数内部变量的**方法**,在`javascript`中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数

​	定义的作用域和执行的作用域不是同一个

**必要条件**

1. 函数嵌套

2. 把内部函数作为返回值返回（不需要加括号）

3. 内部函数必须要用到外部函数的变量　

## 纯函数

​	当一个函数指定输入后,输出永远相同,并且没有任何突变及副作用，有助于提高代码的可测试性和可维护性

**性质**

1. 仅取决于提供的输入,而不依赖于任何在函数求值期间或调用间隔时可能变化的的隐藏状态和外部状态
2. 不会造成超出其作用域的变化,例如修改全局对象或引用传递的参数

**引用透明**

一个函数对于相同的输入始终产生相同的结果,那么就说它是引用透明的

```js
#引用不透明 依赖外部变量
let counter = 0;
function increment(){
	return ++counter;
}

#引用透明 显示定义参数
//相同的输入每次都返回相同的结果
let increment = counter => counter +1
```

**副作用**

只要是跟函数外部环境发生的交互就都是副作用,我们要将副作用在可控的范围内发生

## 高阶函数

高阶函数至少满足下列一个条件

1. 函数的参数是另一个函数

2. 函数返回值为另一个函数

## 柯里化

​	将需要多个参数的函数转化为一个函数的过程,当提供较少的参数时,返回一个等待剩余参数的新函数

```js
function curry(fn, scope, ...args) {
    let
        prex = args,            // 保存上一次的 参数
        context = scope;        // 保存作用域
    let newFn = (...rest) => {
        let last = [...prex, ...rest];  // 合并入参
        return (               // 当没有入参时，执行函数，否则继续柯里化函数
            rest.length > 0 ?
                curry(fn, context, ...last) :
                fn.call(context, ...last)
        )
    }
    return newFn;
}

function add(...args) {
    return args.reduce((last, next) => last + next, 0);
}

var curryAdd = curry(add);
console.log(curryAdd(1, 2, 3)());           // 6
console.log(curryAdd(1, 2)(3)());           // 6
console.log(curryAdd(1)(1)(1)(1)(1)());     // 5
console.log(curryAdd(1, 1)(1, 1)());        // 4
```



特点:

1. 参数可复用
2. 提前确认
3. 延迟运行

## 高阶组件

## 面向对象&&函数式编程

**面向对象**

​	面向对象的核心,就是将创建派生对象作为程序中代码重用的主要手段

​	面向对象使用this的缺点是它给予了超出方法作用域的实力层级的数据访问能力,从而可能导致副作用

**目的**

​		面向对象的应用程序大多是命令式的,在很大程度上依赖于使用基于对象的封装来保护其自身和继承的可变状态的完整性,再通过实例方法来暴露或修改这些状态对象的数据与其具体的行为以一种内聚的包裹的形式紧耦合在一起,而这就是面向对象程序的目的,也正解释了为什么对象是抽象的**核心**

​		

**函数式编程**

​	函数式对象不需要对调用者隐藏数据,通常使用一些更小且非常简单的数据类型,由于一切都是不可变的,对象都是可以直接拿来用的,数据于行为是松耦合的

​	函数式编程更倾向于通过广义的多态函数交叉应用于不同的数据类型,同事避免使用this,更据重用行和可维护性

**两者**

​	面向对象的程序设计通过特定的行为将很多数据类型逻辑地连接在一起,函数式编程则关注如何在这些数据之上通过组合来连接各种操作,两种编程范式都可以被有效利用的平衡点



面向对象的设计着重于数据级数据之间的关系,函数编程则关注于操作如何执行

|            | 函数式                            | 面向对象                 |
| ---------- | --------------------------------- | ------------------------ |
| 组合单元   | 函数                              | 对象(类)                 |
| 编程风格   | 声明式                            | 命令式                   |
| 数据和行为 | 独立且松耦合的纯函数              | 与方法紧耦合的类         |
| 状态管理   | 将对象视为不可变的值              | 主张通过实例方法改变对象 |
| 程序流控制 | 函数与递归                        | 循环与条件               |
| 线程安全   | 可并发编程                        | 难以实现                 |
| 封装性     | 因为一切都是不可变的,所以没有必要 | 需要保护数据的完整性     |

**compose**

https://github.com/reduxjs/redux/blob/v3.7.2/src/compose.js

```js
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**偏函数**

​	通过指定部分参数来产生一个新的定制函数的形式就是偏函数