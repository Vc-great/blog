# 函数类型接口

## Function

输入多余的（或者少于要求的）参数，是不被允许的

```js
function sum(x: number, y: number): number {
    return x + y;
}

```

**函数表达式**

```js
let add = (x:number,y:number)=>x+y;

let muSun = function(x:number,y:number):number{
    return x+y
}
```

​		这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型

```js

let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
    return x + y;
};


let compute : (x:number,y:number)=>number;
compute = (a,b)=>a+b;
```

​		在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。

**可选参数**

​		可选参数必须接在必须参数后面,就是说**可选参数后面不允许再出现必须参数了**

```js
function sum(x: number, y?: number): number {
    return x + y;
}
```

**默认参数**

​		必选参数前默认参数必须赋值可以为`undefined`

```js
function add(x:number,y?=0,z:number,q=1) {
return x+y+z+q
}

console.log(add(1,undefined, 3));
```

剩余参数

​	参数不确定使用剩余参数,数组类型

```js
function add2(x:number,y:number,...rest:number[]) {
    return x+rest.reduce((pre,cur)=>(pre+cur))
}

console.log(add2(1, 2, 3, 4, 5, 6));
```





**重载**

**定义:**允许创建数项名称相同但输入输出类型或个数不同的子程序子程序)，它可以简单地称为一个单独功能可以执行多项任务的能力。

**TS重载:**允许一个函数接受不同数量或类型的参数时,作出不同的处理

```js
function reverse(x:number):number;
function reverse(x:string):string;
function reverse(x:number|string):number|string {
    if (typeof x==='number'){
        return Number(x.toString().split('').reverse().join(''))
    }else if(typeof x ==='string'){
        return x.split('').reverse().join('')
    }
}
```

## 类

### 类

- 类成员的属性都是实例属性
- 类成员的方法都是实例方法

```js
class Dog{
    //实例属性需要有初始值
    constructor(name:string) {
        this.name = name
    }
    name:string
    run(){}
}

console.log(Dog.prototype);
```

### 类的继承

```js
class Husky extends Dog{
    constructor(name:string,color:string) {
        super(name);
        this.color = color;
    }
    color:string
}
```

### 类的修饰符

- 类的修饰符
- public 所有人可见
- private 私有成员 外部和子类都不能调用
- protected 受保护成员 只能在类或者子类中访问 类的实例无法访问
- readonly 只读属性
- //static 静态成员  只能通过类名进行调用 不能用过子类访问

```js
class Dog{
    //private constructor 既不能被实例化 也不能继承
   // protected constructor 不能被实例化  只能被继承 用于基类
    //public color
    private constructor(name:string,public color:string) {
        this.name = name
    }
  public  name:string
  // color:string  因为 public color:string color变为实例属性
    run(){}
    private pri(){}
    protected pro(){}
    readonly legs:number = 4
    static food:string = 'bones'
}
```



## 函数类型接口

- 函数定义   返回值靠TS推断省去
- 变量定义
- 接口定义
- 类型别名

```js
#1
function add(x:number,y:number) {
return x+y
}
#2  变量定义函数类型

let add: (x:number,y:number)=>number;
#3 接口定义函数类型
interface add {
    (x:number,y:number):number
}
#4 类型别名
type Add = (x:number,y:number) =>number



let fn :Add=(a,b)=>a+b
```

## 混合类型接口

- 可以定义函数

- 也可以像对象 有属性和方法

  ```js
  interface Lib {
      ():void; //函数
      version:string; //属性
      doSomething():void //方法
  }
  ```

1. 单例

   ```js
   #单例
   //let lib:Lib=()=>{};
   //提示 缺少属性使用断言
   let lib:Lib=(()=>{})as Lib;
   
   lib:version:'1.0';
   lib.doSomething=()=>{};
   ```

2. 多个实例

   ```js
   function getLib() {
       let lib:Lib=(()=>{})as Lib;
       lib:version:'1.0';
       lib.doSomething=()=>{};
       return lib
   }
   let lib1 = getLib();
   lib1.doSomething();
   ```

